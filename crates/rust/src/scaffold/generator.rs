//! Direct code generation using quote! macro.

use std::collections::HashSet;

use bulloak_syntax::{Action, Ast};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::{
    config::Config,
    constants::{CONTEXT_STRUCT_NAME, PANIC_KEYWORDS},
    scaffold::comment,
    utils::to_snake_case,
};

/// Generate Rust test code from an AST using quote! macro.
pub struct Generator {
    /// Whether to format descriptions.
    format_descriptions: bool,
    /// Whether to skip helper functions.
    skip_helpers: bool,
}

impl Generator {
    /// Create a new generator.
    #[must_use]
    pub fn new(cfg: &Config) -> Self {
        Self {
            format_descriptions: cfg.format_descriptions,
            skip_helpers: cfg.skip_helpers,
        }
    }

    /// Generate complete Rust test file from AST.
    pub fn generate(&self, ast: &Ast) -> anyhow::Result<String> {
        let ast_root = match ast {
            Ast::Root(r) => r,
            _ => anyhow::bail!("Expected Root node"),
        };

        // Generate all parts
        let context_struct = self.generate_context_struct();
        let helpers = if self.skip_helpers {
            TokenStream::new()
        } else {
            self.generate_helpers(&ast_root.children)
        };
        let test_module = self.generate_test_module(&ast_root.children)?;

        // Combine everything
        let tokens = quote! {
            #context_struct

            #helpers

            #test_module
        };

        // Format the output using prettyplease
        let syntax_tree = syn::parse2(tokens)?;
        let mut formatted = prettyplease::unparse(&syntax_tree);

        // Post-process: add header comment
        formatted = format!("// Generated by bulloak\n\n{}", formatted);

        // Post-process: fix doc comment formatting (add space after ///)
        formatted = formatted.replace("///Helper:", "/// Helper:");

        // Post-process: add action comments to test function bodies
        formatted = self.add_test_body_comments(formatted, &ast_root.children);

        Ok(formatted)
    }

    /// Add comments to test function bodies based on action titles.
    fn add_test_body_comments(
        &self,
        formatted: String,
        children: &[Ast],
    ) -> String {
        let mut test_comments = Vec::new();
        self.collect_test_comments(children, &[], &mut test_comments);

        let mut result = formatted;
        for (test_name, comments) in test_comments {
            self.insert_comments_for_test(&mut result, &test_name, &comments);
        }

        result
    }

    /// Insert comments into a specific test function body.
    fn insert_comments_for_test(
        &self,
        result: &mut String,
        test_name: &str,
        comments: &[String],
    ) {
        let pattern = format!("fn {}() {{", test_name);
        let Some(pos) = result.find(&pattern) else {
            return;
        };

        let closing_brace_pos = pos + pattern.len();
        let Some(next_brace) = result[closing_brace_pos..].find('}') else {
            return;
        };

        let body = &result[closing_brace_pos..closing_brace_pos + next_brace];
        let all_comments = comments.join("\n        ");

        if body.trim().is_empty() {
            // Empty body - just add comments with proper indentation
            let comment_str = format!("\n        {}\n    ", all_comments);
            let insertion_pos = closing_brace_pos + next_brace;
            result.insert_str(insertion_pos, &comment_str);
        } else if !body.contains("//") && body.contains("let _ctx") {
            // Has helper call - add comments after it
            let trimmed_body = body.trim_end();
            let chars_to_remove = body.len() - trimmed_body.len();
            result.replace_range(
                closing_brace_pos + next_brace - chars_to_remove
                    ..closing_brace_pos + next_brace,
                &format!("\n        {}\n    ", all_comments),
            );
        }
    }

    /// Collect test function names and their comments (grouped by test
    /// function).
    fn collect_test_comments(
        &self,
        children: &[Ast],
        parent_helpers: &[String],
        comments: &mut Vec<(String, Vec<String>)>,
    ) {
        for child in children {
            match child {
                Ast::Condition(condition) => {
                    let helper_name = to_snake_case(&condition.title);
                    let mut new_helpers = parent_helpers.to_vec();
                    new_helpers.push(helper_name);

                    // Collect all action comments under this condition
                    let action_comments: Vec<String> =
                        Self::collect_actions(&condition.children)
                            .iter()
                            .map(|action| {
                                format!("// {}", self.format_comment(&action.title))
                            })
                            .collect();

                    if !action_comments.is_empty() {
                        let test_name =
                            Self::generate_test_name(&condition.title, &new_helpers);
                        comments.push((test_name, action_comments));
                    }

                    // Process nested conditions
                    self.collect_test_comments(
                        &condition.children,
                        &new_helpers,
                        comments,
                    );
                }
                Ast::Action(action) => {
                    // Root-level action (no condition)
                    if parent_helpers.is_empty() {
                        let test_name =
                            Self::generate_test_name(&action.title, parent_helpers);
                        let comment = format!(
                            "// {}",
                            self.format_comment(&action.title)
                        );
                        comments.push((test_name, vec![comment]));
                    }
                }
                _ => {}
            }
        }
    }

    /// Generate the TestContext struct.
    fn generate_context_struct(&self) -> TokenStream {
        let context_name = format_ident!("{}", CONTEXT_STRUCT_NAME);
        quote! {
            /// Context for test conditions
            #[derive(Default)]
            struct #context_name {
                // Add fields as needed
            }
        }
    }

    /// Generate all helper functions from conditions.
    fn generate_helpers(&self, children: &[Ast]) -> TokenStream {
        let mut helpers = Vec::new();
        let mut seen = HashSet::new();

        self.collect_helpers_recursive(children, &mut helpers, &mut seen);

        let helper_fns: Vec<_> = helpers
            .iter()
            .map(|(name, doc)| self.generate_helper(name, doc))
            .collect();

        quote! {
            #(#helper_fns)*
        }
    }

    /// Recursively collect unique helper functions.
    fn collect_helpers_recursive(
        &self,
        children: &[Ast],
        helpers: &mut Vec<(String, String)>,
        seen: &mut HashSet<String>,
    ) {
        for child in children {
            if let Ast::Condition(condition) = child {
                let name = to_snake_case(&condition.title);
                if seen.insert(name.clone()) {
                    // insert returns true if the value was newly inserted
                    helpers.push((name, condition.title.clone()));
                }
                self.collect_helpers_recursive(
                    &condition.children,
                    helpers,
                    seen,
                );
            }
        }
    }

    /// Generate a single helper function.
    fn generate_helper(&self, name: &str, doc: &str) -> TokenStream {
        let fn_name = format_ident!("{}", name);
        let context_ty = format_ident!("{}", CONTEXT_STRUCT_NAME);
        let doc_comment = format!("Helper: {}", doc);

        quote! {
            #[doc = #doc_comment]
            fn #fn_name(mut ctx: #context_ty) -> #context_ty {
                // TODO: Set up condition
                ctx
            }
        }
    }

    /// Generate the test module.
    fn generate_test_module(
        &self,
        children: &[Ast],
    ) -> anyhow::Result<TokenStream> {
        let test_fns = self.process_children(children, &[])?;

        Ok(quote! {
            #[cfg(test)]
            mod tests {
                use super::*;

                #(#test_fns)*
            }
        })
    }

    /// Process AST children to generate test functions.
    fn process_children(
        &self,
        children: &[Ast],
        parent_helpers: &[String],
    ) -> anyhow::Result<Vec<TokenStream>> {
        let mut test_fns = Vec::new();

        for child in children {
            match child {
                Ast::Condition(condition) => {
                    let helper_name = to_snake_case(&condition.title);
                    let mut new_helpers = parent_helpers.to_vec();
                    new_helpers.push(helper_name);

                    // Collect all direct action children of this condition
                    let actions = Self::collect_actions(&condition.children);

                    if !actions.is_empty() {
                        // Generate a single test function for all actions under
                        // this condition
                        test_fns.push(
                            self.generate_test_function(&actions, &new_helpers)?,
                        );
                    }

                    // Process only nested conditions (not actions, as they were
                    // already processed above)
                    let nested_conditions: Vec<&Ast> = condition
                        .children
                        .iter()
                        .filter(|c| !matches!(c, Ast::Action(_)))
                        .collect();

                    for nested_child in nested_conditions {
                        let Ast::Condition(nested_cond) = nested_child else {
                            continue;
                        };

                        let nested_helper_name = to_snake_case(&nested_cond.title);
                        let mut nested_helpers = new_helpers.clone();
                        nested_helpers.push(nested_helper_name);
                        test_fns.extend(self.process_children(
                            &nested_cond.children,
                            &nested_helpers,
                        )?);
                    }
                }
                Ast::Action(action) => {
                    // Action at root level (no condition)
                    test_fns.push(
                        self.generate_test_function(&[action], parent_helpers)?,
                    );
                }
                _ => {}
            }
        }

        Ok(test_fns)
    }

    /// Generate a test function from one or more actions.
    fn generate_test_function(
        &self,
        actions: &[&Action],
        helpers: &[String],
    ) -> anyhow::Result<TokenStream> {
        if actions.is_empty() {
            anyhow::bail!("Cannot generate test function with no actions");
        }

        // Use the last helper (condition) for the test name if helpers exist
        let test_name = Self::generate_test_name(&actions[0].title, helpers);
        let test_fn_name = format_ident!("{}", test_name);

        // Check if any action should panic
        let should_panic = actions.iter().any(|a| self.should_panic(&a.title));

        // Collect comments from all actions
        let mut comment_lines = Vec::new();
        for action in actions {
            comment_lines
                .push(format!("// {}", self.format_comment(&action.title)));
            for desc_ast in &action.children {
                if let Ast::ActionDescription(desc) = desc_ast {
                    comment_lines.push(format!(
                        "// {}",
                        self.format_comment(&desc.text)
                    ));
                }
            }
        }
        let body_comments = comment_lines.join("\n    ");

        // Generate helper calls
        let helper_calls = Self::build_helper_chain(helpers);

        // Build complete function body as a string
        let body_str = if helper_calls.is_empty() {
            body_comments
        } else {
            format!("{}\n    {}", helper_calls, body_comments)
        };

        // Parse the body as tokens
        let body_tokens: TokenStream = body_str.parse().unwrap_or_else(|_| {
            // Fallback to just comments if parsing fails
            quote! {}
        });

        // Build test function
        let test_fn = if should_panic {
            quote! {
                #[test]
                #[should_panic]
                fn #test_fn_name() {
                    #body_tokens
                }
            }
        } else {
            quote! {
                #[test]
                fn #test_fn_name() {
                    #body_tokens
                }
            }
        };

        Ok(test_fn)
    }

    /// Check if action should panic.
    fn should_panic(&self, title: &str) -> bool {
        let title_lower = title.to_lowercase();
        PANIC_KEYWORDS.iter().any(|keyword| title_lower.contains(keyword))
    }

    /// Format a comment string.
    fn format_comment(&self, text: &str) -> String {
        if self.format_descriptions {
            comment::format_comment(text)
        } else {
            text.to_string()
        }
    }

    /// Generate test function name from action title and helpers.
    fn generate_test_name(action_title: &str, helpers: &[String]) -> String {
        if helpers.is_empty() {
            format!("test_{}", to_snake_case(action_title))
        } else {
            format!("test_when_{}", helpers.last().unwrap())
        }
    }

    /// Collect all direct action children from AST nodes.
    fn collect_actions(children: &[Ast]) -> Vec<&Action> {
        children
            .iter()
            .filter_map(|c| {
                if let Ast::Action(a) = c {
                    Some(a)
                } else {
                    None
                }
            })
            .collect()
    }

    /// Build helper function call chain.
    fn build_helper_chain(helpers: &[String]) -> String {
        if helpers.is_empty() {
            return String::new();
        }

        if helpers.len() == 1 {
            format!(
                "let _ctx = {}({}::default());",
                &helpers[0], CONTEXT_STRUCT_NAME
            )
        } else {
            let mut chain = format!("{}::default()", CONTEXT_STRUCT_NAME);
            for helper in helpers {
                chain = format!("{}({})", helper, chain);
            }
            format!("let _ctx = {};", chain)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bulloak_syntax::{Action, Condition};

    #[test]
    fn test_should_panic() {
        let cfg = Config::default();
        let gen = Generator::new(&cfg);

        assert!(gen.should_panic("It should panic"));
        assert!(gen.should_panic("It should revert"));
        assert!(!gen.should_panic("It should return a value"));
    }

    #[test]
    fn test_generate_test_name_without_helpers() {
        let result = Generator::generate_test_name("It should work", &[]);
        assert_eq!(result, "test_should_work");
    }

    #[test]
    fn test_generate_test_name_with_one_helper() {
        let helpers = vec!["user_is_logged_in".to_string()];
        let result = Generator::generate_test_name("It should succeed", &helpers);
        assert_eq!(result, "test_when_user_is_logged_in");
    }

    #[test]
    fn test_generate_test_name_with_multiple_helpers() {
        let helpers = vec![
            "user_is_logged_in".to_string(),
            "balance_is_zero".to_string(),
        ];
        let result = Generator::generate_test_name("It should fail", &helpers);
        assert_eq!(result, "test_when_balance_is_zero");
    }

    #[test]
    fn test_collect_actions_empty() {
        let children: Vec<Ast> = vec![];
        let actions = Generator::collect_actions(&children);
        assert!(actions.is_empty());
    }

    #[test]
    fn test_collect_actions_mixed() {
        let children = vec![
            Ast::Action(Action {
                title: "action1".to_string(),
                children: vec![],
                span: Default::default(),
            }),
            Ast::Condition(Condition {
                title: "condition1".to_string(),
                children: vec![],
                span: Default::default(),
            }),
            Ast::Action(Action {
                title: "action2".to_string(),
                children: vec![],
                span: Default::default(),
            }),
        ];

        let actions = Generator::collect_actions(&children);
        assert_eq!(actions.len(), 2);
        assert_eq!(actions[0].title, "action1");
        assert_eq!(actions[1].title, "action2");
    }

    #[test]
    fn test_collect_actions_only_conditions() {
        let children = vec![
            Ast::Condition(Condition {
                title: "condition1".to_string(),
                children: vec![],
                span: Default::default(),
            }),
            Ast::Condition(Condition {
                title: "condition2".to_string(),
                children: vec![],
                span: Default::default(),
            }),
        ];

        let actions = Generator::collect_actions(&children);
        assert!(actions.is_empty());
    }

    #[test]
    fn test_build_helper_chain_empty() {
        let result = Generator::build_helper_chain(&[]);
        assert_eq!(result, "");
    }

    #[test]
    fn test_build_helper_chain_single() {
        let helpers = vec!["helper1".to_string()];
        let result = Generator::build_helper_chain(&helpers);
        assert_eq!(result, "let _ctx = helper1(TestContext::default());");
    }

    #[test]
    fn test_build_helper_chain_multiple() {
        let helpers = vec!["helper1".to_string(), "helper2".to_string()];
        let result = Generator::build_helper_chain(&helpers);
        assert_eq!(
            result,
            "let _ctx = helper2(helper1(TestContext::default()));"
        );
    }

    #[test]
    fn test_build_helper_chain_three() {
        let helpers = vec![
            "helper1".to_string(),
            "helper2".to_string(),
            "helper3".to_string(),
        ];
        let result = Generator::build_helper_chain(&helpers);
        assert_eq!(
            result,
            "let _ctx = helper3(helper2(helper1(TestContext::default())));"
        );
    }
}
