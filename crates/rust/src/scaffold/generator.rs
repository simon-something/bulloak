//! Direct code generation using quote! macro.

use bulloak_syntax::{Action, Ast};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::collections::HashSet;

use crate::{
    config::Config,
    constants::{CONTEXT_STRUCT_NAME, PANIC_KEYWORDS},
    scaffold::comment,
    utils::to_snake_case,
};

/// Generate Rust test code from an AST using quote! macro.
pub struct Generator {
    /// Whether to format descriptions.
    format_descriptions: bool,
    /// Whether to skip helper functions.
    skip_helpers: bool,
}

impl Generator {
    /// Create a new generator.
    #[must_use]
    pub fn new(cfg: &Config) -> Self {
        Self {
            format_descriptions: cfg.format_descriptions,
            skip_helpers: cfg.skip_helpers,
        }
    }

    /// Generate complete Rust test file from AST.
    pub fn generate(&self, ast: &Ast) -> anyhow::Result<String> {
        let ast_root = match ast {
            Ast::Root(r) => r,
            _ => anyhow::bail!("Expected Root node"),
        };

        // Generate all parts
        let context_struct = self.generate_context_struct();
        let helpers = if self.skip_helpers {
            TokenStream::new()
        } else {
            self.generate_helpers(&ast_root.children)
        };
        let test_module = self.generate_test_module(&ast_root.children)?;

        // Combine everything
        let tokens = quote! {
            #context_struct

            #helpers

            #test_module
        };

        // Format the output using prettyplease
        let syntax_tree = syn::parse2(tokens)?;
        let mut formatted = prettyplease::unparse(&syntax_tree);

        // Post-process: add header comment
        formatted = format!("// Generated by bulloak\n\n{}", formatted);

        // Post-process: fix doc comment formatting (add space after ///)
        formatted = formatted.replace("///Helper:", "/// Helper:");

        // Post-process: add action comments to test function bodies
        formatted = self.add_test_body_comments(formatted, &ast_root.children);

        Ok(formatted)
    }

    /// Add comments to test function bodies based on action titles.
    fn add_test_body_comments(&self, formatted: String, children: &[Ast]) -> String {
        let mut test_comments = Vec::new();
        self.collect_test_comments(children, &[], &mut test_comments);

        let mut result = formatted;
        for (test_name, comments) in test_comments {
            // Find the test function and add the comments
            let pattern = format!("fn {}() {{", test_name);
            if let Some(pos) = result.find(&pattern) {
                let closing_brace_pos = pos + pattern.len();
                // Check if it's an empty body (just whitespace before })
                if let Some(next_brace) = result[closing_brace_pos..].find('}') {
                    let body = &result[closing_brace_pos..closing_brace_pos + next_brace];
                    // Only add comments if body is empty or just contains helper setup
                    if body.trim().is_empty() {
                        // Empty body - just add comments with proper indentation
                        let all_comments = comments.join("\n        ");
                        let comment_str = format!("\n        {}\n    ", all_comments);
                        let insertion_pos = closing_brace_pos + next_brace;
                        result.insert_str(insertion_pos, &comment_str);
                    } else if !body.contains("//") && body.contains("let _ctx") {
                        // Has helper call - add comments after it
                        let all_comments = comments.join("\n        ");
                        let trimmed_body = body.trim_end();
                        let chars_to_remove = body.len() - trimmed_body.len();
                        result.replace_range(
                            closing_brace_pos + next_brace - chars_to_remove..closing_brace_pos + next_brace,
                            &format!("\n        {}\n    ", all_comments)
                        );
                    }
                }
            }
        }

        result
    }

    /// Collect test function names and their comments (grouped by test function).
    fn collect_test_comments(
        &self,
        children: &[Ast],
        parent_helpers: &[String],
        comments: &mut Vec<(String, Vec<String>)>,
    ) {
        for child in children {
            match child {
                Ast::Condition(condition) => {
                    let helper_name = to_snake_case(&condition.title);
                    let mut new_helpers = parent_helpers.to_vec();
                    new_helpers.push(helper_name);

                    // Collect all action comments under this condition
                    let action_comments: Vec<String> = condition.children.iter()
                        .filter_map(|c| if let Ast::Action(a) = c { Some(a) } else { None })
                        .map(|action| format!("// {}", self.format_comment(&action.title)))
                        .collect();

                    if !action_comments.is_empty() {
                        let test_name = if new_helpers.is_empty() {
                            let action_part = to_snake_case(&condition.title);
                            format!("test_{}", action_part)
                        } else {
                            let last_helper = &new_helpers[new_helpers.len() - 1];
                            format!("test_when_{}", last_helper)
                        };
                        comments.push((test_name, action_comments));
                    }

                    // Process nested conditions
                    self.collect_test_comments(&condition.children, &new_helpers, comments);
                }
                Ast::Action(action) => {
                    // Root-level action (no condition)
                    if parent_helpers.is_empty() {
                        let action_part = to_snake_case(&action.title);
                        let test_name = format!("test_{}", action_part);
                        let comment = format!("// {}", self.format_comment(&action.title));
                        comments.push((test_name, vec![comment]));
                    }
                }
                _ => {}
            }
        }
    }

    /// Generate the TestContext struct.
    fn generate_context_struct(&self) -> TokenStream {
        let context_name = format_ident!("{}", CONTEXT_STRUCT_NAME);
        quote! {
            /// Context for test conditions
            #[derive(Default)]
            struct #context_name {
                // Add fields as needed
            }
        }
    }

    /// Generate all helper functions from conditions.
    fn generate_helpers(&self, children: &[Ast]) -> TokenStream {
        let mut helpers = Vec::new();
        let mut seen = HashSet::new();

        self.collect_helpers_recursive(children, &mut helpers, &mut seen);

        let helper_fns: Vec<_> = helpers
            .iter()
            .map(|(name, doc)| self.generate_helper(name, doc))
            .collect();

        quote! {
            #(#helper_fns)*
        }
    }

    /// Recursively collect unique helper functions.
    fn collect_helpers_recursive(
        &self,
        children: &[Ast],
        helpers: &mut Vec<(String, String)>,
        seen: &mut HashSet<String>,
    ) {
        for child in children {
            if let Ast::Condition(condition) = child {
                let name = to_snake_case(&condition.title);
                if !seen.contains(&name) {
                    seen.insert(name.clone());
                    helpers.push((name, condition.title.clone()));
                }
                self.collect_helpers_recursive(&condition.children, helpers, seen);
            }
        }
    }

    /// Generate a single helper function.
    fn generate_helper(&self, name: &str, doc: &str) -> TokenStream {
        let fn_name = format_ident!("{}", name);
        let context_ty = format_ident!("{}", CONTEXT_STRUCT_NAME);
        let doc_comment = format!("Helper: {}", doc);

        quote! {
            #[doc = #doc_comment]
            fn #fn_name(mut ctx: #context_ty) -> #context_ty {
                // TODO: Set up condition
                ctx
            }
        }
    }

    /// Generate the test module.
    fn generate_test_module(&self, children: &[Ast]) -> anyhow::Result<TokenStream> {
        let test_fns = self.process_children(children, &[])?;

        Ok(quote! {
            #[cfg(test)]
            mod tests {
                use super::*;

                #(#test_fns)*
            }
        })
    }

    /// Process AST children to generate test functions.
    fn process_children(
        &self,
        children: &[Ast],
        parent_helpers: &[String],
    ) -> anyhow::Result<Vec<TokenStream>> {
        let mut test_fns = Vec::new();

        for child in children {
            match child {
                Ast::Condition(condition) => {
                    let helper_name = to_snake_case(&condition.title);
                    let mut new_helpers = parent_helpers.to_vec();
                    new_helpers.push(helper_name);

                    // Collect all direct action children of this condition
                    let actions: Vec<&Action> = condition.children.iter()
                        .filter_map(|c| if let Ast::Action(a) = c { Some(a) } else { None })
                        .collect();

                    if !actions.is_empty() {
                        // Generate a single test function for all actions under this condition
                        test_fns.push(self.generate_test_function_for_condition(&actions, &new_helpers)?);
                    }

                    // Process only nested conditions (not actions, as they were already processed above)
                    let nested_conditions: Vec<&Ast> = condition.children.iter()
                        .filter(|c| !matches!(c, Ast::Action(_)))
                        .collect();

                    for nested_child in nested_conditions {
                        if let Ast::Condition(nested_cond) = nested_child {
                            let nested_helper_name = to_snake_case(&nested_cond.title);
                            let mut nested_helpers = new_helpers.clone();
                            nested_helpers.push(nested_helper_name);
                            test_fns.extend(self.process_children(&nested_cond.children, &nested_helpers)?);
                        }
                    }
                }
                Ast::Action(action) => {
                    // Action at root level (no condition)
                    test_fns.push(self.generate_test_function(&[action], parent_helpers)?);
                }
                _ => {}
            }
        }

        Ok(test_fns)
    }

    /// Generate a test function for a condition with multiple actions.
    fn generate_test_function_for_condition(
        &self,
        actions: &[&Action],
        helpers: &[String],
    ) -> anyhow::Result<TokenStream> {
        self.generate_test_function(actions, helpers)
    }

    /// Generate a test function from one or more actions.
    fn generate_test_function(
        &self,
        actions: &[&Action],
        helpers: &[String],
    ) -> anyhow::Result<TokenStream> {
        if actions.is_empty() {
            anyhow::bail!("Cannot generate test function with no actions");
        }

        // Use the last helper (condition) for the test name if helpers exist
        let test_name = if helpers.is_empty() {
            let action_part = to_snake_case(&actions[0].title);
            format!("test_{}", action_part)
        } else {
            let last_helper = &helpers[helpers.len() - 1];
            format!("test_when_{}", last_helper)
        };

        let test_fn_name = format_ident!("{}", test_name);

        // Check if any action should panic
        let should_panic = actions.iter().any(|a| self.should_panic(&a.title));

        // Collect comments from all actions
        let mut comment_lines = Vec::new();
        for action in actions {
            comment_lines.push(format!("// {}", self.format_comment(&action.title)));
            for desc_ast in &action.children {
                if let Ast::ActionDescription(desc) = desc_ast {
                    comment_lines.push(format!("// {}", self.format_comment(&desc.text)));
                }
            }
        }
        let body_comments = comment_lines.join("\n    ");

        // Generate helper calls
        let helper_calls = if helpers.is_empty() {
            String::new()
        } else if helpers.len() == 1 {
            format!("let _ctx = {}({}::default());", &helpers[0], CONTEXT_STRUCT_NAME)
        } else {
            // Chain multiple helpers
            let mut chain = format!("{}::default()", CONTEXT_STRUCT_NAME);
            for helper in helpers {
                chain = format!("{}({})", helper, chain);
            }
            format!("let _ctx = {};", chain)
        };

        // Build complete function body as a string
        let body_str = if helper_calls.is_empty() {
            body_comments
        } else {
            format!("{}\n    {}", helper_calls, body_comments)
        };

        // Parse the body as tokens
        let body_tokens: TokenStream = body_str.parse().unwrap_or_else(|_| {
            // Fallback to just comments if parsing fails
            quote! {}
        });

        // Build test function
        let test_fn = if should_panic {
            quote! {
                #[test]
                #[should_panic]
                fn #test_fn_name() {
                    #body_tokens
                }
            }
        } else {
            quote! {
                #[test]
                fn #test_fn_name() {
                    #body_tokens
                }
            }
        };

        Ok(test_fn)
    }



    /// Check if action should panic.
    fn should_panic(&self, title: &str) -> bool {
        let title_lower = title.to_lowercase();
        PANIC_KEYWORDS
            .iter()
            .any(|keyword| title_lower.contains(keyword))
    }

    /// Format a comment string.
    fn format_comment(&self, text: &str) -> String {
        if self.format_descriptions {
            comment::format_comment(text)
        } else {
            text.to_string()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_should_panic() {
        let cfg = Config::default();
        let gen = Generator::new(&cfg);

        assert!(gen.should_panic("It should panic"));
        assert!(gen.should_panic("It should revert"));
        assert!(!gen.should_panic("It should return a value"));
    }
}
