//! Emits Rust code from a HIR.

use crate::{
    constants::{CONTEXT_STRUCT_NAME, DEFAULT_INDENTATION},
    hir::{
        visitor::Visitor, Attribute, Comment, ContextStruct, HelperFunction, Hir, Root,
        TestFunction, TestModule,
    },
    scaffold::comment,
};

/// Emits Rust code from a HIR.
pub struct Emitter {
    /// Current indentation level.
    indent: usize,
    /// Whether to format descriptions.
    format_descriptions: bool,
}

impl Emitter {
    /// Create a new emitter.
    #[must_use]
    pub fn new(format_descriptions: bool) -> Self {
        Self {
            indent: 0,
            format_descriptions,
        }
    }

    /// Emit Rust code from the given HIR.
    #[must_use]
    pub fn emit(mut self, hir: &Hir) -> String {
        self.visit(hir)
    }

    /// Get the current indentation string.
    fn indent(&self) -> String {
        " ".repeat(self.indent)
    }

    /// Increase indentation.
    fn push_indent(&mut self) {
        self.indent += DEFAULT_INDENTATION;
    }

    /// Decrease indentation.
    fn pop_indent(&mut self) {
        self.indent = self.indent.saturating_sub(DEFAULT_INDENTATION);
    }

    /// Emit a comment line.
    fn emit_comment(&self, text: &str, should_format: bool) -> String {
        let text = if should_format || self.format_descriptions {
            comment::format_comment(text)
        } else {
            text.to_string()
        };
        format!("{}// {}", self.indent(), text)
    }
}

impl Visitor for Emitter {
    type Output = String;

    fn visit_root(&mut self, root: &Root) -> String {
        let mut parts = vec!["// Generated by bulloak".to_string()];
        parts.push(String::new());

        for child in &root.children {
            let code = self.visit(child);
            if !code.is_empty() {
                parts.push(code);
                parts.push(String::new()); // Blank line between top-level items
            }
        }

        parts.join("\n")
    }

    fn visit_context(&mut self, context: &ContextStruct) -> String {
        let mut parts = Vec::new();

        if let Some(doc) = &context.doc {
            parts.push(format!("/// {}", doc));
        }
        parts.push("#[derive(Default)]".to_string());
        parts.push(format!("struct {} {{", context.name));
        parts.push("    // Add fields as needed".to_string());
        parts.push("}".to_string());

        parts.join("\n")
    }

    fn visit_helper(&mut self, helper: &HelperFunction) -> String {
        let mut parts = Vec::new();

        if let Some(doc) = &helper.doc {
            parts.push(format!("/// Helper: {}", doc));
        }

        parts.push(format!(
            "fn {}(mut ctx: {}) -> {} {{",
            helper.name, CONTEXT_STRUCT_NAME, CONTEXT_STRUCT_NAME
        ));
        parts.push("    // TODO: Set up condition".to_string());
        parts.push("    ctx".to_string());
        parts.push("}".to_string());

        parts.join("\n")
    }

    fn visit_test_module(&mut self, module: &TestModule) -> String {
        let mut parts = vec![
            "#[cfg(test)]".to_string(),
            format!("mod {} {{", module.name),
        ];

        // Add use super::*;
        parts.push("    use super::*;".to_string());
        parts.push(String::new());

        self.push_indent();

        for child in &module.children {
            let code = self.visit(child);
            if !code.is_empty() {
                parts.push(code);
                parts.push(String::new());
            }
        }

        self.pop_indent();

        parts.push("}".to_string());

        parts.join("\n")
    }

    fn visit_test_function(&mut self, func: &TestFunction) -> String {
        let mut parts = Vec::new();

        // Emit attributes
        for attr in &func.attributes {
            let attr_str = match attr {
                Attribute::Test => "#[test]",
                Attribute::ShouldPanic => "#[should_panic]",
            };
            parts.push(format!("{}{}", self.indent(), attr_str));
        }

        // Function signature
        parts.push(format!("{}fn {}() {{", self.indent(), func.name));

        self.push_indent();

        // Call helpers
        if !func.helpers.is_empty() {
            let helpers_chain = if func.helpers.len() == 1 {
                format!(
                    "let _ctx = {}({}::default());",
                    func.helpers[0], CONTEXT_STRUCT_NAME
                )
            } else {
                let mut chain = format!("{}::default()", CONTEXT_STRUCT_NAME);
                for helper in &func.helpers {
                    chain = format!("{}({})", helper, chain);
                }
                format!("let _ctx = {};", chain)
            };
            parts.push(format!("{}{}", self.indent(), helpers_chain));
        }

        // Emit comments
        for child in &func.children {
            let code = self.visit(child);
            if !code.is_empty() {
                parts.push(code);
            }
        }

        self.pop_indent();

        parts.push(format!("{}}}", self.indent()));

        parts.join("\n")
    }

    fn visit_comment(&mut self, comment: &Comment) -> String {
        self.emit_comment(&comment.text, comment.format)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_emit_context() {
        let mut emitter = Emitter::new(false);
        let context = ContextStruct::default();
        let output = emitter.visit_context(&context);

        assert!(output.contains("struct TestContext"));
        assert!(output.contains("#[derive(Default)]"));
    }

    #[test]
    fn test_emit_helper() {
        let mut emitter = Emitter::new(false);
        let helper = HelperFunction {
            name: "when_x_is_greater".to_string(),
            doc: Some("When x is greater".to_string()),
            span: None,
        };
        let output = emitter.visit_helper(&helper);

        assert!(output.contains("fn when_x_is_greater"));
        assert!(output.contains("mut ctx: TestContext"));
        assert!(output.contains("/// Helper: When x is greater"));
    }
}
