// Generated by bulloak

/// Helper function for condition
fn delegate_called() {
}

/// Helper function for condition
fn not_delegate_called() {
}

/// Helper function for condition
fn the_caller_is_a_former_recipient() {
}

/// Helper function for condition
fn the_caller_is_a_malicious_third_party() {
}

/// Helper function for condition
fn the_caller_is_an_approved_third_party() {
}

/// Helper function for condition
fn the_caller_is_authorized() {
}

/// Helper function for condition
fn the_caller_is_the_recipient() {
}

/// Helper function for condition
fn the_caller_is_the_sender() {
}

/// Helper function for condition
fn the_caller_is_unauthorized() {
}

/// Helper function for condition
fn the_id_does_not_reference_a_null_stream() {
}

/// Helper function for condition
fn the_id_references_a_null_stream() {
}

/// Helper function for condition
fn the_recipient_does_not_implement_the_hook() {
}

/// Helper function for condition
fn the_recipient_does_not_revert() {
}

/// Helper function for condition
fn the_recipient_implements_the_hook() {
}

/// Helper function for condition
fn the_recipient_is_a_contract() {
}

/// Helper function for condition
fn the_recipient_is_not_a_contract() {
}

/// Helper function for condition
fn the_recipient_reverts() {
}

/// Helper function for condition
fn the_sender_does_not_implement_the_hook() {
}

/// Helper function for condition
fn the_sender_does_not_revert() {
}

/// Helper function for condition
fn the_sender_implements_the_hook() {
}

/// Helper function for condition
fn the_sender_is_a_contract() {
}

/// Helper function for condition
fn the_sender_is_not_a_contract() {
}

/// Helper function for condition
fn the_sender_reverts() {
}

/// Helper function for condition
fn the_stream_is_cancelable() {
}

/// Helper function for condition
fn the_stream_is_cold() {
}

/// Helper function for condition
fn the_stream_is_not_cancelable() {
}

/// Helper function for condition
fn the_stream_is_warm() {
}

/// Helper function for condition
fn the_streams_status_is_canceled() {
}

/// Helper function for condition
fn the_streams_status_is_depleted() {
}

/// Helper function for condition
fn the_streams_status_is_pending() {
}

/// Helper function for condition
fn the_streams_status_is_settled() {
}

/// Helper function for condition
fn the_streams_status_is_streaming() {
}

/// Helper function for condition
fn there_is_no_reentrancy_1() {
}

/// Helper function for condition
fn there_is_no_reentrancy_2() {
}

/// Helper function for condition
fn there_is_reentrancy_1() {
}

/// Helper function for condition
fn there_is_reentrancy_2() {
}

#[test(should_fail)]
unconstrained fn test_when_delegate_called() {
    delegate_called();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_id_references_a_null_stream() {
    not_delegate_called();
    the_id_references_a_null_stream();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_streams_status_is_depleted() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_cold();
    the_streams_status_is_depleted();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_streams_status_is_canceled() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_cold();
    the_streams_status_is_canceled();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_streams_status_is_settled() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_cold();
    the_streams_status_is_settled();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_caller_is_a_malicious_third_party() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_unauthorized();
    the_caller_is_a_malicious_third_party();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_caller_is_an_approved_third_party() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_unauthorized();
    the_caller_is_an_approved_third_party();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_caller_is_a_former_recipient() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_unauthorized();
    the_caller_is_a_former_recipient();
    // it should revert
}

#[test(should_fail)]
unconstrained fn test_when_the_stream_is_not_cancelable() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_not_cancelable();
    // it should revert
}

#[test]
unconstrained fn test_when_the_streams_status_is_pending() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_pending();
    // it should cancel the stream
    // it should mark the stream as depleted
    // it should make the stream not cancelable
}

#[test]
unconstrained fn test_when_the_recipient_is_not_a_contract() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_sender();
    the_recipient_is_not_a_contract();
    // it should cancel the stream
    // it should mark the stream as canceled
}

#[test(should_fail)]
unconstrained fn test_when_the_recipient_does_not_implement_the_hook() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_sender();
    the_recipient_is_a_contract();
    the_recipient_does_not_implement_the_hook();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the recipient hook
    // it should ignore the revert
}

#[test(should_fail)]
unconstrained fn test_when_the_recipient_reverts() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_sender();
    the_recipient_is_a_contract();
    the_recipient_implements_the_hook();
    the_recipient_reverts();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the recipient hook
    // it should ignore the revert
}

#[test(should_fail)]
unconstrained fn test_when_there_is_reentrancy_1() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_sender();
    the_recipient_is_a_contract();
    the_recipient_implements_the_hook();
    the_recipient_does_not_revert();
    there_is_reentrancy_1();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the recipient hook
    // it should ignore the revert
}

#[test]
unconstrained fn test_when_there_is_no_reentrancy_1() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_sender();
    the_recipient_is_a_contract();
    the_recipient_implements_the_hook();
    the_recipient_does_not_revert();
    there_is_no_reentrancy_1();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should make the stream not cancelable
    // it should update the refunded amount
    // it should refund the sender
    // it should call the recipient hook
    // it should emit a {CancelLockupStream} event
    // it should emit a {MetadataUpdate} event
}

#[test]
unconstrained fn test_when_the_sender_is_not_a_contract() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_recipient();
    the_sender_is_not_a_contract();
    // it should cancel the stream
    // it should mark the stream as canceled
}

#[test(should_fail)]
unconstrained fn test_when_the_sender_does_not_implement_the_hook() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_recipient();
    the_sender_is_a_contract();
    the_sender_does_not_implement_the_hook();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the sender hook
    // it should ignore the revert
}

#[test(should_fail)]
unconstrained fn test_when_the_sender_reverts() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_recipient();
    the_sender_is_a_contract();
    the_sender_implements_the_hook();
    the_sender_reverts();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the sender hook
    // it should ignore the revert
}

#[test(should_fail)]
unconstrained fn test_when_there_is_reentrancy_2() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_recipient();
    the_sender_is_a_contract();
    the_sender_implements_the_hook();
    the_sender_does_not_revert();
    there_is_reentrancy_2();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should call the sender hook
    // it should ignore the revert
}

#[test]
unconstrained fn test_when_there_is_no_reentrancy_2() {
    not_delegate_called();
    the_id_does_not_reference_a_null_stream();
    the_stream_is_warm();
    the_caller_is_authorized();
    the_stream_is_cancelable();
    the_streams_status_is_streaming();
    the_caller_is_the_recipient();
    the_sender_is_a_contract();
    the_sender_implements_the_hook();
    the_sender_does_not_revert();
    there_is_no_reentrancy_2();
    // it should cancel the stream
    // it should mark the stream as canceled
    // it should make the stream not cancelable
    // it should update the refunded amount
    // it should refund the sender
    // it should call the sender hook
    // it should emit a {MetadataUpdate} event
    // it should emit a {CancelLockupStream} event
}


