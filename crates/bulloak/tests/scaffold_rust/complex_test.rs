// Generated by bulloak

/// Context for test conditions
#[derive(Default)]
struct TestContext {}
/// Helper: when delegate called
fn delegate_called(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when not delegate called
fn not_delegate_called(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the id references a null stream
fn the_id_references_a_null_stream(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the id does not reference a null stream
fn the_id_does_not_reference_a_null_stream(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the stream is cold
fn the_stream_is_cold(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the streams status is DEPLETED
fn the_streams_status_is_d_e_p_l_e_t_e_d(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the streams status is CANCELED
fn the_streams_status_is_c_a_n_c_e_l_e_d(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the streams status is SETTLED
fn the_streams_status_is_s_e_t_t_l_e_d(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the stream is warm
fn the_stream_is_warm(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is unauthorized
fn the_caller_is_unauthorized(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is a malicious third party
fn the_caller_is_a_malicious_third_party(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is an approved third party
fn the_caller_is_an_approved_third_party(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is a former recipient
fn the_caller_is_a_former_recipient(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is authorized
fn the_caller_is_authorized(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the stream is not cancelable
fn the_stream_is_not_cancelable(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the stream is cancelable
fn the_stream_is_cancelable(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the streams status is PENDING
fn the_streams_status_is_p_e_n_d_i_n_g(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the streams status is STREAMING
fn the_streams_status_is_s_t_r_e_a_m_i_n_g(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is the sender
fn the_caller_is_the_sender(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the recipient is not a contract
fn the_recipient_is_not_a_contract(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the recipient is a contract
fn the_recipient_is_a_contract(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the recipient does not implement the hook
fn the_recipient_does_not_implement_the_hook(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the recipient implements the hook
fn the_recipient_implements_the_hook(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the recipient reverts
fn the_recipient_reverts(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the recipient does not revert
fn the_recipient_does_not_revert(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when there is reentrancy 1
fn there_is_reentrancy_1(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when there is no reentrancy 1
fn there_is_no_reentrancy_1(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the caller is the recipient
fn the_caller_is_the_recipient(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the sender is not a contract
fn the_sender_is_not_a_contract(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the sender is a contract
fn the_sender_is_a_contract(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the sender does not implement the hook
fn the_sender_does_not_implement_the_hook(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: given the sender implements the hook
fn the_sender_implements_the_hook(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the sender reverts
fn the_sender_reverts(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when the sender does not revert
fn the_sender_does_not_revert(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when there is reentrancy 2
fn there_is_reentrancy_2(mut ctx: TestContext) -> TestContext {
    ctx
}
/// Helper: when there is no reentrancy 2
fn there_is_no_reentrancy_2(mut ctx: TestContext) -> TestContext {
    ctx
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    #[should_panic]
    fn test_when_delegate_called() {
        let _ctx = delegate_called(TestContext::default());
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_id_references_a_null_stream() {
        let _ctx = the_id_references_a_null_stream(
            not_delegate_called(TestContext::default()),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_streams_status_is_d_e_p_l_e_t_e_d() {
        let _ctx = the_streams_status_is_d_e_p_l_e_t_e_d(
            the_stream_is_cold(
                the_id_does_not_reference_a_null_stream(
                    not_delegate_called(TestContext::default()),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_streams_status_is_c_a_n_c_e_l_e_d() {
        let _ctx = the_streams_status_is_c_a_n_c_e_l_e_d(
            the_stream_is_cold(
                the_id_does_not_reference_a_null_stream(
                    not_delegate_called(TestContext::default()),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_streams_status_is_s_e_t_t_l_e_d() {
        let _ctx = the_streams_status_is_s_e_t_t_l_e_d(
            the_stream_is_cold(
                the_id_does_not_reference_a_null_stream(
                    not_delegate_called(TestContext::default()),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_caller_is_a_malicious_third_party() {
        let _ctx = the_caller_is_a_malicious_third_party(
            the_caller_is_unauthorized(
                the_stream_is_warm(
                    the_id_does_not_reference_a_null_stream(
                        not_delegate_called(TestContext::default()),
                    ),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_caller_is_an_approved_third_party() {
        let _ctx = the_caller_is_an_approved_third_party(
            the_caller_is_unauthorized(
                the_stream_is_warm(
                    the_id_does_not_reference_a_null_stream(
                        not_delegate_called(TestContext::default()),
                    ),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_caller_is_a_former_recipient() {
        let _ctx = the_caller_is_a_former_recipient(
            the_caller_is_unauthorized(
                the_stream_is_warm(
                    the_id_does_not_reference_a_null_stream(
                        not_delegate_called(TestContext::default()),
                    ),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    #[should_panic]
    fn test_when_the_stream_is_not_cancelable() {
        let _ctx = the_stream_is_not_cancelable(
            the_caller_is_authorized(
                the_stream_is_warm(
                    the_id_does_not_reference_a_null_stream(
                        not_delegate_called(TestContext::default()),
                    ),
                ),
            ),
        );
        // it should revert
    }
    #[test]
    fn test_when_the_streams_status_is_p_e_n_d_i_n_g() {
        let _ctx = the_streams_status_is_p_e_n_d_i_n_g(
            the_stream_is_cancelable(
                the_caller_is_authorized(
                    the_stream_is_warm(
                        the_id_does_not_reference_a_null_stream(
                            not_delegate_called(TestContext::default()),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as depleted
        // it should make the stream not cancelable
    }
    #[test]
    fn test_when_the_streams_status_is_p_e_n_d_i_n_g() {
        let _ctx = the_streams_status_is_p_e_n_d_i_n_g(
            the_stream_is_cancelable(
                the_caller_is_authorized(
                    the_stream_is_warm(
                        the_id_does_not_reference_a_null_stream(
                            not_delegate_called(TestContext::default()),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    fn test_when_the_streams_status_is_p_e_n_d_i_n_g() {
        let _ctx = the_streams_status_is_p_e_n_d_i_n_g(
            the_stream_is_cancelable(
                the_caller_is_authorized(
                    the_stream_is_warm(
                        the_id_does_not_reference_a_null_stream(
                            not_delegate_called(TestContext::default()),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    fn test_when_the_recipient_is_not_a_contract() {
        let _ctx = the_recipient_is_not_a_contract(
            the_caller_is_the_sender(
                the_streams_status_is_s_t_r_e_a_m_i_n_g(
                    the_stream_is_cancelable(
                        the_caller_is_authorized(
                            the_stream_is_warm(
                                the_id_does_not_reference_a_null_stream(
                                    not_delegate_called(TestContext::default()),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
    }
    #[test]
    fn test_when_the_recipient_is_not_a_contract() {
        let _ctx = the_recipient_is_not_a_contract(
            the_caller_is_the_sender(
                the_streams_status_is_s_t_r_e_a_m_i_n_g(
                    the_stream_is_cancelable(
                        the_caller_is_authorized(
                            the_stream_is_warm(
                                the_id_does_not_reference_a_null_stream(
                                    not_delegate_called(TestContext::default()),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_the_recipient_does_not_implement_the_hook() {
        let _ctx = the_recipient_does_not_implement_the_hook(
            the_recipient_is_a_contract(
                the_caller_is_the_sender(
                    the_streams_status_is_s_t_r_e_a_m_i_n_g(
                        the_stream_is_cancelable(
                            the_caller_is_authorized(
                                the_stream_is_warm(
                                    the_id_does_not_reference_a_null_stream(
                                        not_delegate_called(TestContext::default()),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the recipient hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_the_recipient_reverts() {
        let _ctx = the_recipient_reverts(
            the_recipient_implements_the_hook(
                the_recipient_is_a_contract(
                    the_caller_is_the_sender(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the recipient hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_the_recipient_reverts() {
        let _ctx = the_recipient_reverts(
            the_recipient_implements_the_hook(
                the_recipient_is_a_contract(
                    the_caller_is_the_sender(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    fn test_when_the_recipient_reverts() {
        let _ctx = the_recipient_reverts(
            the_recipient_implements_the_hook(
                the_recipient_is_a_contract(
                    the_caller_is_the_sender(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_the_recipient_reverts() {
        let _ctx = the_recipient_reverts(
            the_recipient_implements_the_hook(
                the_recipient_is_a_contract(
                    the_caller_is_the_sender(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_there_is_reentrancy_1() {
        let _ctx = there_is_reentrancy_1(
            the_recipient_does_not_revert(
                the_recipient_implements_the_hook(
                    the_recipient_is_a_contract(
                        the_caller_is_the_sender(
                            the_streams_status_is_s_t_r_e_a_m_i_n_g(
                                the_stream_is_cancelable(
                                    the_caller_is_authorized(
                                        the_stream_is_warm(
                                            the_id_does_not_reference_a_null_stream(
                                                not_delegate_called(TestContext::default()),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the recipient hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_there_is_no_reentrancy_1() {
        let _ctx = there_is_no_reentrancy_1(
            the_recipient_does_not_revert(
                the_recipient_implements_the_hook(
                    the_recipient_is_a_contract(
                        the_caller_is_the_sender(
                            the_streams_status_is_s_t_r_e_a_m_i_n_g(
                                the_stream_is_cancelable(
                                    the_caller_is_authorized(
                                        the_stream_is_warm(
                                            the_id_does_not_reference_a_null_stream(
                                                not_delegate_called(TestContext::default()),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should make the stream not cancelable
        // it should update the refunded amount
        // it should refund the sender
        // it should call the recipient hook
        // it should emit a {CancelLockupStream} event
        // it should emit a {MetadataUpdate} event
    }
    #[test]
    fn test_when_the_sender_is_not_a_contract() {
        let _ctx = the_sender_is_not_a_contract(
            the_caller_is_the_recipient(
                the_streams_status_is_s_t_r_e_a_m_i_n_g(
                    the_stream_is_cancelable(
                        the_caller_is_authorized(
                            the_stream_is_warm(
                                the_id_does_not_reference_a_null_stream(
                                    not_delegate_called(TestContext::default()),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
    }
    #[test]
    fn test_when_the_sender_is_not_a_contract() {
        let _ctx = the_sender_is_not_a_contract(
            the_caller_is_the_recipient(
                the_streams_status_is_s_t_r_e_a_m_i_n_g(
                    the_stream_is_cancelable(
                        the_caller_is_authorized(
                            the_stream_is_warm(
                                the_id_does_not_reference_a_null_stream(
                                    not_delegate_called(TestContext::default()),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_the_sender_does_not_implement_the_hook() {
        let _ctx = the_sender_does_not_implement_the_hook(
            the_sender_is_a_contract(
                the_caller_is_the_recipient(
                    the_streams_status_is_s_t_r_e_a_m_i_n_g(
                        the_stream_is_cancelable(
                            the_caller_is_authorized(
                                the_stream_is_warm(
                                    the_id_does_not_reference_a_null_stream(
                                        not_delegate_called(TestContext::default()),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the sender hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_the_sender_reverts() {
        let _ctx = the_sender_reverts(
            the_sender_implements_the_hook(
                the_sender_is_a_contract(
                    the_caller_is_the_recipient(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the sender hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_the_sender_reverts() {
        let _ctx = the_sender_reverts(
            the_sender_implements_the_hook(
                the_sender_is_a_contract(
                    the_caller_is_the_recipient(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    fn test_when_the_sender_reverts() {
        let _ctx = the_sender_reverts(
            the_sender_implements_the_hook(
                the_sender_is_a_contract(
                    the_caller_is_the_recipient(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_the_sender_reverts() {
        let _ctx = the_sender_reverts(
            the_sender_implements_the_hook(
                the_sender_is_a_contract(
                    the_caller_is_the_recipient(
                        the_streams_status_is_s_t_r_e_a_m_i_n_g(
                            the_stream_is_cancelable(
                                the_caller_is_authorized(
                                    the_stream_is_warm(
                                        the_id_does_not_reference_a_null_stream(
                                            not_delegate_called(TestContext::default()),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
    }
    #[test]
    #[should_panic]
    fn test_when_there_is_reentrancy_2() {
        let _ctx = there_is_reentrancy_2(
            the_sender_does_not_revert(
                the_sender_implements_the_hook(
                    the_sender_is_a_contract(
                        the_caller_is_the_recipient(
                            the_streams_status_is_s_t_r_e_a_m_i_n_g(
                                the_stream_is_cancelable(
                                    the_caller_is_authorized(
                                        the_stream_is_warm(
                                            the_id_does_not_reference_a_null_stream(
                                                not_delegate_called(TestContext::default()),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should call the sender hook
        // it should ignore the revert
    }
    #[test]
    fn test_when_there_is_no_reentrancy_2() {
        let _ctx = there_is_no_reentrancy_2(
            the_sender_does_not_revert(
                the_sender_implements_the_hook(
                    the_sender_is_a_contract(
                        the_caller_is_the_recipient(
                            the_streams_status_is_s_t_r_e_a_m_i_n_g(
                                the_stream_is_cancelable(
                                    the_caller_is_authorized(
                                        the_stream_is_warm(
                                            the_id_does_not_reference_a_null_stream(
                                                not_delegate_called(TestContext::default()),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        // it should cancel the stream
        // it should mark the stream as canceled
        // it should make the stream not cancelable
        // it should update the refunded amount
        // it should refund the sender
        // it should call the sender hook
        // it should emit a {MetadataUpdate} event
        // it should emit a {CancelLockupStream} event
    }
}

